using System.Threading;
using System.Numerics;
using System;
using Sandbox;

namespace OMMovement
{
    public class Water : AirAccelerate
    {
		public int WaterLevel{get; set;} = 0;
		public int OldWaterLevel{get; set;} = 0;
		public float JumpTime{get; set;} = 0.0f;
		public float JumpHeight{get; private set;} = 8.0f;
		public float EntryTime{get; private set;} = 0.0f;
		public Vector3 JumpVel{get; set;}

        public Water(MovementController controller) : base(controller)
		{
		}

		public virtual void CheckJump()
		{
			var forward = Controller.Rotation.Forward;
			var	flat_forward = forward.Normal;
			var	flat_velocity = Controller.Velocity;
			var pawn = Controller.Pawn;
			var cur_speed;

			// Already water jumping.
			if (JumpTime != 0)
				return;

			// Don't hop out if we just jumped in
			if (Controller.Velocity.z < -180.0f)
				return; // only hop out if we are moving up

			// See if we are backing up
			flat_velocity = flat_velocity.WithZ(0);

			// Must be moving
			cur_speed = flat_velocity.Length;
			
			// see if near an edge
			flat_forward = flat_forward.WithZ(0);

			// Are we backing into water from steps or something?  If so, don't pop forward
			if (cur_speed != 0.0f && (flat_velocity.Dot(flat_forward) < 0.0f))
				return;

			// Start line trace at waist height (using the center of the player for this here)
			var trace_start = Controller.Position + (Controller.Properties.OBBMins + Controller.Properties.OBBMaxs) * 0.5;
			var trace_end = trace_start + flat_forward * 24.0f; //VectorMA( vecStart, 24.0f, flatforward, vecEnd );
			var trace = Controller.TraceBBox(trace_start, trace_end);

			// solid at waist
			if (trace.Fraction < 1.0f)
			{
				trace_start = trace_start.WithZ(Controller.Position.z + Controller.Properties.ViewOffset + JumpHeight); 
				trace_end = trace_start + flat_forward * 24.0f;
				JumpVel = trace.Normal * -50.0f;
				trace = Controller.TraceBBox(trace_start, trace_end);

				// open at eye level
				if (trace.Fraction == 1.0)
				{
					// Now trace down to see if we would actually land on a standable surface.
					trace_start = trace_end;
					trace_end = trace_end.WithZ(trace_end.z - 1024.0f);
					trace = Controller.TraceBBox(trace_start, trace_end);

					if (trace.Fraction < 1.0f && trace.Normal.z >= 0.7f)
					{
						// Push Up
						Controller.Velocity = Controller.Velocity.WithZ(256.0f);
						// Do this for 2 seconds
						WaterJump = 2000.0f;
						//player->AddFlag( FL_WATERJUMP );
					}
				}
			}
		}

		public virtual void Jump()
		{
			if (JumpTime > 10000.0f)
					JumpTime = 10000.0f;

				if (JumpTime == 0)
					return;

				JumpTime -= 1000.0f * Time.Delta;

				if (JumpTime <= 0 || WaterLevel == 0)
				{
					JumpTime = 0;
					//player->RemoveFlag( FL_WATERJUMP );
				}
				Controller.Velocity = new Vector(JumpVel.x, JumpVel.y, Controller.Velocity.z);
		}

		public virtual bool InWater()
		{
			return (WaterLevel > WATERLEVEL.Feet);
		}

		public virtual bool CheckWater()
		{
			// Assume that we are not in water at all.
			WaterLevel = WATERLEVEL.NotInWater;
			
			// Are we under water? (not solid and not empty?)
			if (Controller.IsInWater)
			{
				// Set water type
				//player->SetWaterType( cont );

				// We are at least at level one
				WaterLevel = WATERLEVEL.Feet;

				// Now check a point that is at the player hull midpoint.
				if (Controller.Fraction > 0.5f)
				{
					// Set a higher water level.
					WaterLevel = WATERLEVEL.Waist;

					// Now check the eye position.  (view_ofs is relative to the origin)
					if (Controller.Fraction > (Controller.Properties.ViewOffset/Controller.Properties.OBBMaxs.z))
						WaterLevel = WATERLEVEL.Eyes;
				}
			}

			// if we just transitioned from not in water to in water, record the time it happened
			if ((WATERLEVEL.NotInWater == OldWaterLevel) && (WaterLevel > WATERLEVEL.NotInWater))
			{
				EntryTime = Time.Now;
			}

			return InWater();
		}

		public override Vector3 WishVel()
		{
			var forward = Controller.Rotation.Forward;
			var forward_speed = Controller.Input.Forward * StrafeSpeed;
			var side_speed = Controller.Input.Left * StrafeSpeed;
			var forward_wish = forward.Normal * forward_speed;
			var side_wish = new Vector3(forward.y, -forward.x, forward.z).Normal * side_speed;

			return forward_wish + side_wish;
		}

		public override void Move()
		{
			var	wish_vel, wish_speed, wish_dir, temp_vel;
			var	start_trace, end_trace, trace;
			var speed, addspeed, accelspeed;
			var forward = Controller.Rotation.Forward;
			var side = new Vector(forward.y, -forward.x, forward.z);
			var up = Controller.Rotation.Up;
			var forward_speed = Controller.Input.Forward * StrafeSpeed;
			var side_speed = Controller.Input.Left * StrafeSpeed;
			var up_speed = Controller.Input.Up * StrafeSpeed;
			var props = Controller.Properties;
			var pos = Controller.Position;

			wish_vel = WishVel();

			// if we have the jump key down, move us up as well
			if (Controller.Input.Down(InputButton.Jump))
			{
				wish_vel.WithZ(wish_vel.z + MaxSpeed);
			}
			// Sinking after no other movement occurs
			else if (forward_speed == 0 && side_speed == 0 && up_speed == 0)
			{
				wish_vel.WithZ(wish_vel.z - 60);
			}
			else  // Go straight up by upmove amount.
			{
				// exaggerate upward movement along forward as well
				wish_vel.WithZ(wish_vel.z + (up_speed + MathX.Clamp(forward_speed * forward.z * 2, 0.0f, MaxSpeed)));
			}

			// Copy it over and determine speed
			wish_dir = wish_vel.Normal;
			//wish_vel = wish_vel * (MaxSpeed/wish_vel.Length);
			wish_speed = GetWishSpeed(wish_vel.Length);

			// Slow us down a bit.
			wishspeed *= 0.8;
			
			// Water friction
			speed = Controller.Velocity.Length;

			if (speed > 0)
			{
				new_speed = speed - Time.Delta * speed * Controller.Friction.Value;

				if (new_speed < 0.1f)
				{
					new_speed = 0;
				}

				Controller.Velocity *= new_speed/speed;
			}

			// water acceleration
			if (wish_speed >= 0.1f)
			{
				add_speed = wish_speed - new_speed;

				if (add_speed > 0)
				{
					var delta_speed = Controller.Accelerate.GetAccelSpeed(wish_dir, wish_speed, add_speed);
					Controller.Velocity += delta_speed;
				}
			}
			Controller.Velocity += Controller.BaseVelocity;

			// Now move
			// assume it is a stair or a slope, so press down from stepheight above
			end_trace = pos + Controller.Velocity * Time.Delta; 
			trace = Controller.TraceBBox(pos, end_trace);

			if (trace.Fraction == 1.0f)
			{
				start_trace = end_trace;
				if (props.AllowAutoMovement)
				{
					start.WithZ(start_trace.z + props.StepSize + 1);
				}
				
				trace = Controller.TraceBBox(start_trace, end_trace);
				
				if (!trace.StartedSolid)
				{	
					//float stepDist = trace.EndPos.z - pos.z;
					//mv->m_outStepHeight += stepDist;
					Controller.Position = trace.EndPos;
					Controller.Velocity -= Controller.BaseVelocity;
					return;
				}

				// Try moving straight along out normal path.
				Controller.TryPlayerMove();
			}
			else
			{
				if (!Controller.OnGround())
				{
					Controller.TryPlayerMove();
					Controller.Velocity -= Controller.BaseVelocity;
					return;
				}

				Controller.StepMove(end_trace, trace);
			}

			Controller.Velocity -= Controller.BaseVelocity;
		}
    }
}
